-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParClbla where
import AbsClbla
import LexClbla
import ErrM

}

%name pEnv Env
%name pExp Exp
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  '->' { PT _ (TS _ 3) }
  '::' { PT _ (TS _ 4) }
  ';' { PT _ (TS _ 5) }
  '=' { PT _ (TS _ 6) }
  'data' { PT _ (TS _ 7) }
  '|' { PT _ (TS _ 8) }
  L_UpperCaseString { PT _ (T_UpperCaseString $$) }
  L_LowerCaseString { PT _ (T_LowerCaseString $$) }

%%

UpperCaseString :: { UpperCaseString}
UpperCaseString  : L_UpperCaseString { UpperCaseString ($1)}

LowerCaseString :: { LowerCaseString}
LowerCaseString  : L_LowerCaseString { LowerCaseString ($1)}

Env :: { Env }
Env : ListInstruction { AbsClbla.Enviorment (reverse $1) }
ListInstruction :: { [Instruction] }
ListInstruction : {- empty -} { [] }
                | ListInstruction Instruction ';' { flip (:) $1 $2 }
Instruction :: { Instruction }
Instruction : Instruction1 { $1 }
            | TypeDefinition { AbsClbla.InstructionTypeDefinition $1 }
            | FunctionDefinition { AbsClbla.InstructionFunctionDefinition $1 }
            | FunctionDeclaration { AbsClbla.InstructionFunctionDeclaration $1 }
Instruction1 :: { Instruction }
Instruction1 : Instruction2 { $1 }
Instruction2 :: { Instruction }
Instruction2 : Instruction3 { $1 }
Instruction3 :: { Instruction }
Instruction3 : '(' Instruction ')' { $2 }
TypeDefinition :: { TypeDefinition }
TypeDefinition : 'data' TypeName Parameters '=' AlgebraicTypeBody { AbsClbla.TypeDefinition $2 $3 $5 }
TypeName :: { TypeName }
TypeName : UpperCaseString { AbsClbla.TypeName $1 }
Parameters :: { Parameters }
Parameters : ListVariable { AbsClbla.Parameters (reverse $1) }
ListVariable :: { [Variable] }
ListVariable : {- empty -} { [] }
             | ListVariable Variable { flip (:) $1 $2 }
Variable :: { Variable }
Variable : LowerCaseString { AbsClbla.Variable $1 }
AlgebraicTypeBody :: { AlgebraicTypeBody }
AlgebraicTypeBody : ListAlgebraicTypeBodyElement { AbsClbla.AlgebraicTypeBody (reverse $1) }
ListAlgebraicTypeBodyElement :: { [AlgebraicTypeBodyElement] }
ListAlgebraicTypeBodyElement : {- empty -} { [] }
                             | ListAlgebraicTypeBodyElement AlgebraicTypeBodyElement '|' { flip (:) $1 $2 }
AlgebraicTypeBodyElement :: { AlgebraicTypeBodyElement }
AlgebraicTypeBodyElement : TypeConstructor ListType { AbsClbla.AlgebraicTypeBodyElement $1 (reverse $2) }
TypeConstructor :: { TypeConstructor }
TypeConstructor : UpperCaseString { AbsClbla.TypeConstructor $1 }
ListType :: { [Type] }
ListType : {- empty -} { [] } | ListType Type { flip (:) $1 $2 }
Type :: { Type }
Type : TypeName Parameters { AbsClbla.NamedType $1 $2 }
     | Variable { AbsClbla.TypeVariable $1 }
     | Type '->' Type { AbsClbla.FunctionType $1 $3 }
     | '(' Type ')' { $2 }
FunctionDeclaration :: { FunctionDeclaration }
FunctionDeclaration : Variable '::' Type { AbsClbla.FunctionDeclaration $1 $3 }
FunctionName :: { FunctionName }
FunctionName : Variable { AbsClbla.FunctionName $1 }
FunctionDefinition :: { FunctionDefinition }
FunctionDefinition : Variable '=' Exp { AbsClbla.FunctionDefinition $1 $3 }
Exp :: { Exp }
Exp : Exp Exp { AbsClbla.Application $1 $2 }
    | '(' Exp ')' { $2 }
    | Variable { AbsClbla.VariableExp $1 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

